import logger from '../utils/logger';
import dotenv from 'dotenv';
import { t } from '../services/i18nService';
import { ROAST_AI_CONFIG } from '../config/botConfig';

// Load environment variables if they haven't been loaded yet
if (!process.env.LMSTUDIO_API_URL) {
  dotenv.config();
}

// LM Studio API URL (default: http://localhost:1234/v1)
const LM_STUDIO_API_URL = process.env.LMSTUDIO_API_URL || 'http://localhost:1234/v1';

/**
 * Clean the API response by removing the original prompt if it's echoed back
 * @param response Text generated by the API
 * @param prompt Original prompt sent
 * @returns Cleaned text
 */
function cleanResponse(response: string, prompt: string): string {
  // Remove the prompt if it's at the beginning of the response
  if (response.startsWith(prompt)) {
    return response.substring(prompt.length).trim();
  }

  // Search for common response patterns
  const patterns = ROAST_AI_CONFIG.PATTERNS;

  for (const pattern of patterns) {
    const match = response.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }

  return response.trim();
}

/**
 * Get a random fallback roast from translations
 * @returns A random fallback roast
 */
function getRandomFallbackRoast(): string {
  // Define a set of default fallbacks in case translation fails
  const defaultFallbacks = ROAST_AI_CONFIG.FALLBACK_ROASTS;

  try {
    // Try to get translations from i18n
    const translationKey = 'services.roastAI.fallback_roasts';
    const translations = t(translationKey);

    // Handle different return types
    if (Array.isArray(translations)) {
      // If it's an array, pick a random item
      if (translations.length > 0) {
        const randomIndex = Math.floor(Math.random() * translations.length);
        return String(translations[randomIndex]);
      }
    } else if (typeof translations === 'string') {
      // If it's a string, return it directly
      return translations;
    }

    // If no valid translations were found, use defaults
    const randomIndex = Math.floor(Math.random() * defaultFallbacks.length);
    return defaultFallbacks[randomIndex];
  } catch (error) {
    // In case of any error with translations, return a default
    return defaultFallbacks[0];
  }
}

/**
 * Get a dynamic roast generated by the AI
 * @param trigger Text that triggered the roast (message, activity, etc.)
 * @returns Promise that resolves to the generated roast
 */
export async function getDynamicRoast(trigger: string): Promise<string> {
  try {
    // Build the prompt for the AI
    const prompt = ROAST_AI_CONFIG.PROMPT(trigger);

    // Configuration for LM Studio (compatible with OpenAI)
    const requestOptions: RequestInit = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: ROAST_AI_CONFIG.MODEL, // The name doesn't matter for local LM Studio
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        max_tokens: ROAST_AI_CONFIG.MAX_TOKENS,
        temperature: ROAST_AI_CONFIG.TEMPERATURE,
      }),
    };

    // Make the request to the LM Studio API
    const response = await fetch(`${LM_STUDIO_API_URL}/chat/completions`, requestOptions);

    // Check if the request was successful
    if (!response.ok) {
      throw new Error(`API failure: ${response.status} ${response.statusText}`);
    }

    // Parse the response (OpenAI format)
    const data = await response.json();

    // Extract the generated text
    const generatedText = data.choices?.[0]?.message?.content || '';

    // Clean and verify the response
    if (!generatedText) {
      throw new Error('Empty response from API');
    }

    const cleanedResponse = cleanResponse(generatedText, prompt);

    // Check if the cleaned response is valid
    if (!cleanedResponse || cleanedResponse.length < 3) {
      throw new Error('Invalid cleaned response');
    }

    return cleanedResponse;
  } catch (error) {
    // Log the error and return a fallback phrase
    logger.error(
      `Error getting dynamic roast: ${error instanceof Error ? error.message : String(error)}`
    );
    return getRandomFallbackRoast();
  }
}

/**
 * Get a dynamic roast with fallback in case of error
 * @param trigger Text that triggered the roast
 * @returns Promise that resolves to the generated roast or a fallback phrase
 */
export async function getReliableRoast(trigger: string): Promise<string> {
  try {
    // Try to get a dynamic roast
    return await getDynamicRoast(trigger);
  } catch (error) {
    // In case of error, return a random fallback phrase
    return getRandomFallbackRoast();
  }
}

export default {
  getDynamicRoast,
  getReliableRoast,
};
